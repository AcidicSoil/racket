#lang racket
(require racket/base)
(require racket/string)

(define (count-over n L)
  (cond
    [(empty? L) 0]
    [(cons? L)
     (+ (count-over n (rest L))
        (cond
          [(> (first L) n) 1]
          [else 0]))]))

(define (add-small L)
  (cond
    [(empty? L) 0]
    [else
     (cond
       [(< (first L) 20)
        (+ (first L) (add-small (rest L)))]
       [else
        (add-small (rest L))])]))

(define (add-big L)
  (cond
    [(empty? L) 0]
    [else
     (cond
       [(> (first L) 200)
        (+ (first L) (add-big (rest L)))]
       [else
        (add-big (rest L))])]))

(define add1
  (lambda (n)
    (+ n 1)))

(define sub1
  (lambda (n)
    (- n 1)))

(define plus
  (lambda (n m)
    (cond
      [(zero? m) n]
      [else (add1 (plus n (sub1 m)))])))

(define minus
  (lambda (n m)
    (cond
      [(zero? m) n]
      [else (sub1 (minus (sub1 m)))])))

(define addtup
  (lambda (tup)
    (cond
      ((null? tup) 0)
      (else
       (plus (car tup) (addtup (cdr tup)))))))

(define times
  (lambda (n m)
    (cond
      [(zero? m) 0]
      [else
       (plus n (times n (sub1 m)))])))

(define tup+
  (lambda (tup1 tup2)
    (cond
      [(null? tup1) tup2]
      [(null? tup2) tup1]
      [else
       (cons (plus (car tup1) (car tup2))
             (tup+
              (cdr tup1)(cdr tup2)))])))

(define >
  (lambda (n m)
    (cond
      [(zero? n) false]
      [(zero? m) true]
      [else
       (> (sub1 n) (sub1 m))])))

(define <
  (lambda (n m)
    (cond
      [(zero? m) false]
      [(zero? n) true]
      [else
       (< (sub1 n) (sub1 m))])))

(define =
  (lambda (n m)
    (cond
      [(> n m) false]
      [(< n m) false]
      [else true])))


(define ^
  (lambda (n m)
    (cond
      [(zero? m) 1]
      [else (times n (^ n (sub1 m)))])))

(define div
  (lambda (n m)
    (cond
      [(< n m) 0]
      [else (add1 (div (minus n m) m))])))



(define (add-even L)
  (cond
    [(null? L) 0]
    [(not(= (modulo (first L) 2) 0))
     (add-even (rest L))]
    [else
     (+ (first L) (add-even (rest L)))]))

(define (add-odd L)
  (cond
    [(null? L) 0]
    [(= (modulo (first L) 2) 0)
     (add-odd (rest L))]
    [else
     (+ (first L) (add-odd (rest L)))]))
               

(define (add-even-subtract-odd L)
  (cond
    [(null? L) 0]
    [(cons? L)
     (- (add-even L) (add-odd L))]))

(define (l-t-100? n)
  (< 100 n))

(define (g-t-50? n)
  (> 50 n))

(define (add-medium L)
  (cond
    [(null? L) 0]
    [(and (l-t-100? (first L))
          (g-t-50? (first L)))
     (add-medium (rest L))]
    [else
     (+ (first L) (add-medium (rest L)))]))

(define (math-sentence L)
  (cond
    [(empty? L) (quote ())]
    [else
     (cond
       [(number? (first L))
        (cons (first L)
              (cond
                [(empty? (math-sentence (rest L)))
                 (quote ())]
                [else 
                 (cons "+" (math-sentence (rest L)))]))]
       [else (cons (first L)
                   (math-sentence  (rest L)))])])) 

(define (list-of-strings L)
  (cond
    [(empty? L)  (quote ())]
    [else
     (cond
       [(string? (first L))
        (cons
         (first L)
         (cond
           [(empty? (list-of-strings (rest L)))
            (cons  "." (list-of-strings (rest L)))]
           [else
            (cons  "" (list-of-strings (rest L)))]))]
       [else  (cons (first L)
                    (list-of-strings (rest L)))])])) 

(define (sentence L)
  (string-append* (list-of-strings L)))

(define multiinsertR
  (lambda (new old lat)
    (cond
      [(null? lat) (quote ())]
      [else
       (cond
         [(eq? (car lat) old)
          (cons (car lat)
                (cons new
                      (multiinsertR new old
                                    (cdr lat))))]
         [else (cons (car lat)
                     (multiinsertR new old
                                   (cdr lat)))])])))

(define insertR
  (lambda (new old lat)
    (cond
      ((null? lat) (quote ()))
      (else
       (cond
         ((eq? (car lat) old)
          (cons old
                (cons new (cdr lat))))
         (else (cons (car lat)
                     (insertR new old
                              (cdr lat)))))))))

#|(define (hyphen 

(define (insert old new L)
  (cond
    [(empty? L) (quote())]
    [else
     (cond
       [(eq? (first L)  |#


(define (hyph-helper L)
  (cond
    [(empty? L) (quote ())]
    [else
     (cond
       [(string? (first L))
        (cons (first L)
              (cond
                [(empty? (hyph-helper (rest L)))
                 (quote ())]
                [else 
                 (cons  "-" (hyph-helper (rest L)))]))]
       [else (cons (first L)
                   (hyph-helper  (rest L)))])]))

(define (hyphenate-words L)
  (cond
    [(empty? L) (quote())]
    [else
     (sentence (hyph-helper L))])) 

(define (cram-small-helper L)
  (cond
    [(empty? L) (quote())]
    [(< (string-length (first L)) 5)
     (cons
      (first L)
      (cram-small-helper (rest L)))]
    [else
     (cram-small-helper (rest L))]))

(define (cram-small L)
  (cond
    [(empty? L) (quote())]
    [(cons? L)
     (sentence (cram-small-helper L))]))


#|(define (circle-sequence L)
  (cond
    [(null? L) 0]|#
    
